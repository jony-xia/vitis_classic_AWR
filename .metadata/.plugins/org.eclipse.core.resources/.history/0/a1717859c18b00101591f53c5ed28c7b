<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mmWaveLink Framework</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">mmWaveLink Framework </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p >TI Automotive and Industrial mmWave Radar products are highly-integrated 77GHz CMOS millimeter wave devices.The devices integrate all of the RF and Analog functionality, including VCO, PLL, PA, LNA, Mixer and ADC for multiple TX/RX channels into a single chip.<br  />
</p><ol type="1">
<li>The AWR1243/AWR2243/xWR6243 is an RF transceiver device and it includes 4 receiver channels and 3 transmit channels in a single chip. AWR2243/xWR6243 also support multi-chip cascading. <br  />
</li>
<li>The AWR1443/IWR1443 is a mmwave radar-on-a-chip device, which includes 4 receive channels and 3 transmit channels and additionally an Cortex R4F and hardware FFT accelerator.<br  />
</li>
<li>AWR1642 and IWR1642 are mmwave radar-on-a-chip device, which includes 4 receive channels and 2 transmit channels and additionally an Cortex R4F and C674x DSP for signal processing</li>
</ol>
<p >TI mmWave radar devices include a mmwave front end or BIST (Built-in Self-Test) processor, which is responsible to configure the RF/Analog and digital front-end in real-time, as well as to periodically schedule calibration and functional safety monitoring.This enables the mmwave front-end(BIST processor) to be self-contained and capable of adapting itself to handle temperature and ageing effects, and to enable significant ease-of-use from an external host perspective.</p>
<p >TI mmwave front end is a closed subsystem whose internal blocks are configurable using messages coming over mailbox.<br  />
 TI mmWaveLink provides APIs generates these message and sends it to mmwave front end over mailbox. It also includes acknowledement and CRC for each message to provide a reliable communication</p>
<p >TI mmWaveLink Framework:</p><ul>
<li>Is a link between application and mmwave front end.</li>
<li>Provides low level APIs to configure the front end and handles the communication with the front end.</li>
<li>Is platform and OS independent which means it can be ported into any processor which provides communication interface such as SPI and basic OS routines. The mmWaveLink framework can also run in single threaded environment</li>
<li>Is integrated into mmWave SDK and can run on R4F or DSP and communicates with mmwave front end over Mailbox interface</li>
</ul>
<div class="image">
<img src="mmwl_block_diagram.png" alt=""/>
</div>
<h1><a class="anchor" id="modules_sec"></a>
Modules</h1>
<p >To make it simple, TI's mmWaveLink framework capabilities are divided into modules.<br  />
 These capabilities include device control, RF/Analog configuration, ADC configuration, Data path(LVDS/CSI2) cofiguration, FMCW chirp configuration and more.<br  />
 Listed below are the various modules in the mmWaveLink framework:</p><ol type="1">
<li><a class="el" href="group___device.html">Device</a> - Controls mmwave radar device which include: <pre class="fragment"> Initialization, such as: mmwave device power On/Off, Firmware Patch download
 Cascade device configuration such as Add/Connect multiple mmWave devices
</pre></li>
<li><a class="el" href="group___sensor.html">Sensor</a> - The RF/Sensor Configuration module controls the different HW blocks inside mmWave Front end.</li>
</ol>
<div class="image">
<img src="mmwave_frontend.png" alt=""/>
</div>
<p >mmWave Front End has below key blocks</p><ol type="1">
<li>Chirp sequencer (Radar Timing Engine) - This block is responsible for constructing the sequence of FMCW chirps or frames and programming the timing engine</li>
<li>Rx/Tx Channel - This defines how many Rx and Tx channel needs to be enabled. Also it defines how to configure the mmWave front end in cascade mode for Imaging Radar</li>
<li>Rx Analog Chain - This defines how the received signal is mixed and how different filters in the chain can be configured</li>
<li>ADC and Digital Front End Configuration - This defines how the IF data is digitized and how it is sampled for further processing in the DSP or Hardware Accelerator. Same ADC data can be sent over LVDS/CSI2 interface to an extenal processor</li>
</ol>
<p >The configuration APIs can further be categorized as.<br  />
</p><ol type="1">
<li>mmwave static configuration, such as: Tx and Rx channel, ADC configuration etc</li>
<li>mmwave dynamic configuration, such as FMCW Chirp configuration, profile configuration</li>
<li>mmwave advance configuration such as Binary phase modulation, Dynamic power save etc</li>
<li>mmwave sensor control, such as: Frame start/stop</li>
</ol>
<p ><a class="el" href="group___data___path.html">Data Path</a> - The Data path Configuration module controls the high speed interface in mmWave device.</p>
<div class="image">
<img src="data_path.png" alt=""/>
</div>
<p >The configuration APIs include.<br  />
</p><ol type="1">
<li>High Speed interface(LVDS/CSI2) selection</li>
<li>Data format and rate configuration</li>
<li>ADC, Chirp Profile(CP), Chirp Quality(CQ) data transfer sequence</li>
<li>Lane configurations</li>
<li>LVDS/CSI2 specific configuration</li>
</ol>
<p ><a class="el" href="group___monitoring.html">Monitoring</a> - The Monitoring/Calibration module configures the calibration and functional safety monitoring in mmWave device</p>
<p >TI mmWave Front end includes built-in processor that is programmed by TI to handle RF calibrations and functional safety monitoring. The RF calibrations ensure that the performance of the device is maintained across temperature and process corners</p>
<ol type="1">
<li><a class="el" href="group___communication___protocol.html">Communication Protocol</a> - The mmWave communication protocol ensures reliable communication between host(internal or external) and mmWave Front end.<ol type="a">
<li>It is a simple stop and wait protocol. Each message needs to be acknowledged by receiver before next message can be sent.</li>
<li>Messages are classifieds as "Command", "Response" and "Asynchronous Event"</li>
<li>If Command can not be processed immediately, ACK response is sent immediately (If requested). "Asynchronous Event" is sent upon completion of the command execution.</li>
</ol>
</li>
</ol>
<div class="image">
<img src="comm_prot.png" alt=""/>
</div>
<h1><a class="anchor" id="proting_sec"></a>
Porting Guide</h1>
<p >The porting of the mmWaveLink driver to any new platform is based on few simple steps. This guide takes you through this process step by step. Please follow the instructions carefully to avoid any problems during this process and to enable efficient and proper work with the device. Please notice that all modifications and porting adjustments of the driver should be made in the application only and driver should not be modified. Changes in the application file will ensure smoothly transaction to new versions of the driver at the future!</p>
<h2><a class="anchor" id="porting_step1"></a>
Step 1 - Define mmWaveLink client callback structure</h2>
<p >The mmWaveLink framework is ported to different platforms using mmWaveLink client callbacks. These callbacks are grouped as different structures such as OS callbacks, Communication Interface callbacks and others. Application needs to define these callbacks and initialize the mmWaveLink framework with the structure. </p><pre class="fragment">@code
rlClientCbs_t clientCtx = { 0 };
rlReturnVal_t retVal;
rlUInt32_t deviceMap = RL_DEVICE_MAP_CASCADED_1;
@endcode
</pre><p> Refer to <a class="el" href="structrl_client_cbs__t.html">rlClientCbs_t</a> for more details</p>
<h2><a class="anchor" id="porting_step2"></a>
Step 2 - Implement Communication Interface Callbacks</h2>
<p >The mmWaveLink device support several standard communication protocol among SPI and MailBox Depending on device variant, one need to choose the communication channel. For e.g xWR1443/xWR1642/xWR1843 requires Mailbox interface and AWR1243/AWR2243/xWR6243 supports SPI interface. The interface for this communication channel should include 4 simple access functions:</p><ol type="1">
<li>rlComIfOpen</li>
<li>rlComIfClose</li>
<li>rlComIfRead</li>
<li><p class="startli">rlComIfWrite</p>
<div class="fragment"><div class="line">clientCtx.comIfCb.rlComIfOpen = Host_spiOpen;</div>
<div class="line">clientCtx.comIfCb.rlComIfClose = Host_spiClose;</div>
<div class="line">clientCtx.comIfCb.rlComIfRead = Host_spiRead;</div>
<div class="line">clientCtx.comIfCb.rlComIfWrite = Host_spiWrite;</div>
</div><!-- fragment --></li>
</ol>
<p >Refer to <a class="el" href="structrl_com_if_cbs__t.html">rlComIfCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step3"></a>
Step 3 - Implement Device Control Interface</h2>
<p >The mmWaveLink driver internally powers on/off the mmWave radar device. The exact implementation of these interface is platform dependent, hence you need to implement below functions:</p><ol type="1">
<li>rlDeviceEnable</li>
<li>rlDeviceDisable</li>
<li><p class="startli">rlRegisterInterruptHandler</p>
<div class="fragment"><div class="line">clientCtx.devCtrlCb.rlDeviceDisable = Host_disableDevice;</div>
<div class="line">clientCtx.devCtrlCb.rlDeviceEnable = Host_enableDevice;</div>
<div class="line">clientCtx.devCtrlCb.rlDeviceMaskHostIrq = Host_spiIRQMask;</div>
<div class="line">clientCtx.devCtrlCb.rlDeviceUnMaskHostIrq = Host_spiIRQUnMask;</div>
<div class="line">clientCtx.devCtrlCb.rlRegisterInterruptHandler = Host_registerInterruptHandler;</div>
<div class="line">clientCtx.devCtrlCb.rlDeviceWaitIrqStatus = Host_deviceWaitIrqStatus;</div>
</div><!-- fragment --></li>
</ol>
<p >Refer to <a class="el" href="structrl_device_ctrl_cbs__t.html">rlDeviceCtrlCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step4"></a>
Step 4 - Implement Event Handlers</h2>
<p >The mmWaveLink driver reports asynchronous event indicating mmwave radar device status, exceptions etc. Application can register this callback to receive these notification and take appropriate actions</p>
<div class="fragment"><div class="line">clientCtx.eventCb.rlAsyncEvent = Host_asyncEventHandler;</div>
</div><!-- fragment --><p >Refer to <a class="el" href="structrl_event_cbs__t.html">rlEventCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step5"></a>
Step 5 - Implement OS Interface</h2>
<p >The mmWaveLink driver can work in both OS and NonOS environment. If Application prefers to use operating system, it needs to implement basic OS routines such as tasks, mutex and Semaphore. In Case of Non-OS environment application needs to implement equivalent form of mutex &amp; semaphore.</p>
<div class="fragment"><div class="line">clientCtx.osiCb.mutex.rlOsiMutexCreate = Host_osiLockObjCreate;</div>
<div class="line">clientCtx.osiCb.mutex.rlOsiMutexLock = Host_osiLockObjLock;</div>
<div class="line">clientCtx.osiCb.mutex.rlOsiMutexUnLock = Host_osiLockObjUnlock;</div>
<div class="line">clientCtx.osiCb.mutex.rlOsiMutexDelete = Host_osiLockObjDelete;</div>
<div class="line"> </div>
<div class="line">clientCtx.osiCb.sem.rlOsiSemCreate = Host_osiSyncObjCreate;</div>
<div class="line">clientCtx.osiCb.sem.rlOsiSemWait = Host_osiSyncObjWait;</div>
<div class="line">clientCtx.osiCb.sem.rlOsiSemSignal = Host_osiSyncObjSignal;</div>
<div class="line">clientCtx.osiCb.sem.rlOsiSemDelete = Host_osiSyncObjDelete;</div>
<div class="line"> </div>
<div class="line">clientCtx.osiCb.queue.rlOsiSpawn = Host_osiSpawn;</div>
<div class="line"> </div>
<div class="line">clientCtx.timerCb.rlDelay = Host_osiSleep;</div>
</div><!-- fragment --><p >Refer to <a class="el" href="structrl_osi_cbs__t.html">rlOsiCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step6"></a>
Step 6 - Implement CRC Interface and Type</h2>
<p >The mmWaveLink driver uses CRC for message integrity. If Application prefers to use CRC, it needs to implement CRC routine and provides the CRC type.</p>
<div class="fragment"><div class="line">clientCtx.crcCb.rlComputeCRC = Host_computeCRC;</div>
<div class="line">clientCtx.crcType = RL_CRC_TYPE_32BIT;</div>
</div><!-- fragment --><p >Refer to <a class="el" href="structrl_crc_cbs__t.html">rlCrcCbs_t</a> for interface details </p><dl class="section note"><dt>Note</dt><dd>: Recommended CRC type is RL_CRC_TYPE_32BIT for AWR1243/AWR2243/xWR6243 device.</dd></dl>
<h2><a class="anchor" id="porting_step7"></a>
Step 7 - Implement Debug Interface</h2>
<p >The mmWaveLink driver can print the debug message. If Application prefers to enable debug messages, it needs to implement debug callback.</p>
<p >Refer to <a class="el" href="structrl_dbg_cb__t.html">rlDbgCb_t</a> for interface details</p>
<h2><a class="anchor" id="porting_final"></a>
Final Step - Initializing mmWaveLink Driver</h2>
<p >Once all the above Interfaces are implemented, Application need to fill these callbacks in <a class="el" href="structrl_client_cbs__t.html">rlClientCbs_t</a> and Initialize mmWaveLink by passing the client callbacks. Application also need to define where the mmWaveLink driver is running, for e.g, External Host in case of AWR1243/AWR2243/xWR6243 or MSS/DSS in case of xWR1642/xWR1843.</p>
<pre class="fragment">@code
clientCtx.platform = RL_PLATFORM_HOST;
clientCtx.arDevType = RL_AR_DEVICETYPE_12XX;

retVal = rlDevicePowerOn(deviceMap, clientCtx);
@endcode
</pre> <h2><a class="anchor" id="porting_crc"></a>
CRC Type Implementation</h2>
<p >Device sets same CRC type as recieved command to response message. So change to command's CRC type will cause a change to response's CRC type as well. [Refer to <a class="el" href="index.html#porting_step7">Step 7 - Implement Debug Interface</a>]. mmWave device(MasterSS &amp; RadarSS) uses 16-bit CRC type by default for async-event messages. If Host needs to set different CRC type to Async-event then it must implement the following code snippet.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structrl_rf_dev_cfg__t.html">rlRfDevCfg_t</a> rfDevCfg = {0x0};</div>
<div class="line"><span class="comment">// set global and monitoring async event direction to Host</span></div>
<div class="line">rfDevCfg.<a class="code hl_variable" href="structrl_rf_dev_cfg__t.html#aace6fb8be5fce2ccab8317c76517b041">aeDirection</a> = 0x05;</div>
<div class="line"><span class="comment">// Set the CRC type of Async event received from RadarSS</span></div>
<div class="line">rfDevCfg.<a class="code hl_variable" href="structrl_rf_dev_cfg__t.html#a631cbbdcfb1a7cbeb9614898b2d1717c">aeCrcConfig</a> = RL_CRC_TYPE_32BIT;</div>
<div class="line">retVal = <a class="code hl_function" href="group___sensor.html#ga25ff76b7e26d26a184fd1c778cb4bf2f">rlRfSetDeviceCfg</a>(deviceMap, &amp;rfDevCfg);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structrl_dev_misc_cfg__t.html">rlDevMiscCfg_t</a> devMiscCfg = {0};</div>
<div class="line"><span class="comment">// Set the CRC Type for Async Event from MSS</span></div>
<div class="line">devMiscCfg.<a class="code hl_variable" href="structrl_dev_misc_cfg__t.html#a57699a74ff329b9b31c9f1419e4d29df">aeCrcConfig</a> = RL_CRC_TYPE_32BIT;</div>
<div class="line">retVal = <a class="code hl_function" href="group___device.html#gafd0e92938bf3698507b97bcd083117c5">rlDeviceSetMiscConfig</a>(deviceMap, &amp;devMiscCfg);</div>
<div class="ttc" id="agroup___device_html_gafd0e92938bf3698507b97bcd083117c5"><div class="ttname"><a href="group___device.html#gafd0e92938bf3698507b97bcd083117c5">rlDeviceSetMiscConfig</a></div><div class="ttdeci">MMWL_EXPORT rlReturnVal_t rlDeviceSetMiscConfig(rlUInt8_t deviceMap, rlDevMiscCfg_t *data)</div><div class="ttdoc">Setup misc. device configurations.</div><div class="ttdef"><b>Definition:</b> <a href="rl__device_8c_source.html#l01688">rl_device.c:1688</a></div></div>
<div class="ttc" id="agroup___sensor_html_ga25ff76b7e26d26a184fd1c778cb4bf2f"><div class="ttname"><a href="group___sensor.html#ga25ff76b7e26d26a184fd1c778cb4bf2f">rlRfSetDeviceCfg</a></div><div class="ttdeci">MMWL_EXPORT rlReturnVal_t rlRfSetDeviceCfg(rlUInt8_t deviceMap, rlRfDevCfg_t *data)</div><div class="ttdoc">: Set different RadarSS device configurations</div><div class="ttdef"><b>Definition:</b> <a href="rl__sensor_8c_source.html#l01899">rl_sensor.c:1899</a></div></div>
<div class="ttc" id="astructrl_dev_misc_cfg__t_html"><div class="ttname"><a href="structrl_dev_misc_cfg__t.html">rlDevMiscCfg_t</a></div><div class="ttdoc">mmwave radar device config</div><div class="ttdef"><b>Definition:</b> <a href="rl__device_8h_source.html#l01079">rl_device.h:1080</a></div></div>
<div class="ttc" id="astructrl_dev_misc_cfg__t_html_a57699a74ff329b9b31c9f1419e4d29df"><div class="ttname"><a href="structrl_dev_misc_cfg__t.html#a57699a74ff329b9b31c9f1419e4d29df">rlDevMiscCfg_t::aeCrcConfig</a></div><div class="ttdeci">rlUInt8_t aeCrcConfig</div><div class="ttdoc">Set CRC type of Async Event message from MSS to Host   0 - 16 Bit CRC   1 - 32 Bit CRC   2 - 64 Bit C...</div><div class="ttdef"><b>Definition:</b> <a href="rl__device_8h_source.html#l01088">rl_device.h:1088</a></div></div>
<div class="ttc" id="astructrl_rf_dev_cfg__t_html"><div class="ttname"><a href="structrl_rf_dev_cfg__t.html">rlRfDevCfg_t</a></div><div class="ttdoc">API RF device Config SBC M_API_AR_RF_DEV_CONF_SBC.</div><div class="ttdef"><b>Definition:</b> <a href="rl__sensor_8h_source.html#l01874">rl_sensor.h:1875</a></div></div>
<div class="ttc" id="astructrl_rf_dev_cfg__t_html_a631cbbdcfb1a7cbeb9614898b2d1717c"><div class="ttname"><a href="structrl_rf_dev_cfg__t.html#a631cbbdcfb1a7cbeb9614898b2d1717c">rlRfDevCfg_t::aeCrcConfig</a></div><div class="ttdeci">rlUInt8_t aeCrcConfig</div><div class="ttdoc">CRC Config for Asynchornous event message   Value Description   0 16 bit CRC for radarSS async events...</div><div class="ttdef"><b>Definition:</b> <a href="rl__sensor_8h_source.html#l01947">rl_sensor.h:1947</a></div></div>
<div class="ttc" id="astructrl_rf_dev_cfg__t_html_aace6fb8be5fce2ccab8317c76517b041"><div class="ttname"><a href="structrl_rf_dev_cfg__t.html#aace6fb8be5fce2ccab8317c76517b041">rlRfDevCfg_t::aeDirection</a></div><div class="ttdeci">rlUInt32_t aeDirection</div><div class="ttdoc">Bit Definition   b1:0 Global Async event direction   00 - radarSS to MSS 01 - radarSS to HOST  10 - r...</div><div class="ttdef"><b>Definition:</b> <a href="rl__sensor_8h_source.html#l01889">rl_sensor.h:1889</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="porting_be"></a>
Big Endian Support</h2>
<p >The mmWaveLink driver by default is enabled for Little Endian host. Support for Big Endian is provided as compile time option using a Pre-processor Macro MMWL_BIG_ENDIAN. <br  />
 For memory optimizations, mmWaveLink doesn't swap the data elements in structure buffer. It is the responsibility of the application to swap multi byte data elements before passing the structure buffer to mmWaveLink API. Since SPI word-size is 16bit, Swap of 32 bit fields such as integer needs to be done at 16bit boundary. </p><dl class="section note"><dt>Note</dt><dd>1: Please refer latest mmWave device DFP release notes for all known issues and de-featured APIs. <br  />
 </dd>
<dd>
2: All reserved bits/bytes in API sub blocks shall be programmed with value zero. The functionality of radar device is not guaranteed if reserved bytes are not zero. <br  />
 </dd>
<dd>
3: All reserved bits/bytes in API message reports shall be masked off. <br  />
 </dd></dl>
<h2><a class="anchor" id="notes"></a>
General Notes</h2>
<ol type="1">
<li>Host should ensure that there is a delay of at least 2 SPI clocks between CS going low and start of SPI clock.</li>
<li>Host should ensure that CS is toggled for every 16 bits of transfer via SPI.</li>
<li>There should be a delay of at least 2 SPI Clocks between consecutive CS.</li>
<li>SPI needs to be operated at Mode 0 (Phase 1, Polarity 0).</li>
<li>SPI word length should be 16 bit (Half word).</li>
</ol>
<h2><a class="anchor" id="appl_notes"></a>
Application Care Abouts</h2>
<ol type="1">
<li>Retry of RF Power up message is unsupported.</li>
<li>HOST is recommended to wait for RF Power Async msg before any further APIs are issued. Lack of RF Power up Async msg should be treated as bootup failure.</li>
<li>It is recommended to wait for Async event for Latent fault injection API before the next CMD is issued.</li>
<li>HOST to ensure a delay of 30us in response to the HOST_IRQ interrupt, to allow for a SPI DMA configuration in device post HOST_IRQ set high.</li>
<li>It is recommended to use 232 as the chunk size in mmWavelink/HOST when firmware download is done through SPI.</li>
</ol>
<h2><a class="anchor" id="api_error_handling"></a>
API Error Handling and Error Codes</h2>
<p >This section describes the error handling of various fault messages in device and information about error codes. The AWR2243/xWR6243 device sends out error info in the form of AE messages in case of any fault in the device. <br  />
 The ERROR_CODE returned part of monitor AE message reports are informative purpose only, these error codes are helpful to debug the cause for monitor failure. <br  />
 Application can log these information and share with TI in case of any runtime errors. The information about these error codes are documented in the "API Error Codes" section. <br  />
 The Application shall handle the monitor failures reported in STATUS_FLAGS part of monitor AE message appropriately, device may not need restart in these error cases and these errors needs to be handled case by case. For example AWR_MONITOR_RX_GAIN_PHASE_REPORT_AE_SB can report failure in presence of interference, this is not a fatal error in the device. <br  />
 Please refer Monitoring app note for more info on monitor reports and thresholds. <br  />
 The information about API_RESP Error codes returned in ACK messages part of AWR_RESP_ERROR_SB for each API commands are documented in "API Error Codes" section, these error codes are helpful to debug the cause for API failure and errors can be corrected during development time. <br  />
 The following AE messages are Fatal errors and device shall be restarted upon receiving these messages:</p><ol type="1">
<li>AWR_AE_RF_CPUFAULT_SB</li>
<li>AWR_AE_RF_ESMFAULT_SB for ESM_GROUP2_ERRORS only</li>
<li>AWR_ANALOGFAULT_AE_SB</li>
<li>AWR_AE_MSS_CPUFAULT_SB</li>
<li>AWR_AE_MSS_ESMFAULT_STATUS_SB for ESM_GROUP2_ERRORS only</li>
<li>AWR_AE_MSS_RFERROR_STATUS_SB for cases ERROR_STATUS_FLAG = 0x1, 0x2 and 0x4 only</li>
<li>AWR_AE_RF_ESMFAULT_SB for PROG_FILT_FATAL_PARITY_ERROR and PROG_FILT_FATAL_DB_ECC_ERROR in ESM_GROUP1_ERRORS only</li>
<li>AWR_AE_MSS_ESMFAULT_STATUS_SB for "FRC Lock Step Error" in ESM_GROUP1_ERRORS only </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<hr size="1"><small>
Copyright  2025, Texas Instruments Incorporated</small>
</body>
</html>
