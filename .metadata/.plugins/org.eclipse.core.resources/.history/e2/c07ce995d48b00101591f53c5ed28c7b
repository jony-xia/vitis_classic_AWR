#include "xspips.h"
#include "xparameters.h"
#include "host.h"
#include <stdint.h>
#include <stdio.h>
#include "xgpiops.h"

#define SPI0_DEVICE_ID   XPAR_XSPIPS_0_DEVICE_ID
#define SPI1_DEVICE_ID   XPAR_XSPIPS_1_DEVICE_ID

// 假定 nRESET/IRQ 连接到 PS GPIO0 的某些引脚，具体编号请查硬件原理图
#define GPIO_DEVICE_ID   XPAR_XGPIOPS_0_DEVICE_ID
#define RESET_PIN_0      10    // SPI0对应AWR2243的nRESET引脚编号
#define RESET_PIN_1      11    // SPI1对应AWR2243的nRESET引脚编号
#define IRQ_PIN_0        12    // SPI0对应AWR2243的IRQ引脚编号
#define IRQ_PIN_1        13    // SPI1对应AWR2243的IRQ引脚编号

static XSpiPs Spi0, Spi1;
static XGpioPs Gpio;

// SPI打开
int32_t Host_spiOpen(uint8_t deviceIndex, void **handle)
{
    XSpiPs_Config *Config;
    int status;

    if (deviceIndex == 0) {
        Config = XSpiPs_LookupConfig(SPI0_DEVICE_ID);
        if (!Config) return -1;
        status = XSpiPs_CfgInitialize(&Spi0, Config, Config->BaseAddress);
        *handle = &Spi0;
    } else if (deviceIndex == 1) {
        Config = XSpiPs_LookupConfig(SPI1_DEVICE_ID);
        if (!Config) return -1;
        status = XSpiPs_CfgInitialize(&Spi1, Config, Config->BaseAddress);
        *handle = &Spi1;
    } else {
        return -1;
    }

    if (status != XST_SUCCESS) return -1;

    XSpiPs_SetOptions(*handle, XSPIPS_MASTER_OPTION | XSPIPS_FORCE_SSELECT_OPTION);
    XSpiPs_SetClkPrescaler(*handle, XSPIPS_CLK_PRESCALE_64); // 可根据速率需求调整
    XSpiPs_SetSlaveSelect(*handle, 0);

    return 0;
}

// SPI关闭
int32_t Host_spiClose(void *handle)
{
    // XSpiPs为裸机驱动，无需特殊关闭
    return 0;
}

// SPI写
int32_t Host_spiWrite(void *handle, uint8_t *buf, uint16_t len)
{
    XSpiPs *Spi = (XSpiPs *)handle;
    return XSpiPs_PolledTransfer(Spi, buf, NULL, len) == XST_SUCCESS ? 0 : -1;
}

// SPI读
int32_t Host_spiRead(void *handle, uint8_t *buf, uint16_t len)
{
    XSpiPs *Spi = (XSpiPs *)handle;
    uint8_t dummy[256] = {0};
    if (len > sizeof(dummy)) return -1;
    return XSpiPs_PolledTransfer(Spi, dummy, buf, len) == XST_SUCCESS ? 0 : -1;
}

// 设备使能（拉高nRESET）
int32_t Host_enableDevice(uint8_t deviceIndex)
{
    int status = XGpioPs_Initialize(&Gpio, GPIO_DEVICE_ID);
    if (status != XST_SUCCESS) return -1;

    uint32_t pin = (deviceIndex == 0) ? RESET_PIN_0 : RESET_PIN_1;
    XGpioPs_SetDirectionPin(&Gpio, pin, 1); // 输出
    XGpioPs_SetOutputEnablePin(&Gpio, pin, 1);
    XGpioPs_WritePin(&Gpio, pin, 1); // 拉高nRESET
    return 0;
}

// 设备失能（拉低nRESET）
int32_t Host_disableDevice(uint8_t deviceIndex)
{
    int status = XGpioPs_Initialize(&Gpio, GPIO_DEVICE_ID);
    if (status != XST_SUCCESS) return -1;

    uint32_t pin = (deviceIndex == 0) ? RESET_PIN_0 : RESET_PIN_1;
    XGpioPs_SetDirectionPin(&Gpio, pin, 1); // 输出
    XGpioPs_SetOutputEnablePin(&Gpio, pin, 1);
    XGpioPs_WritePin(&Gpio, pin, 0); // 拉低nRESET
    return 0;
}
